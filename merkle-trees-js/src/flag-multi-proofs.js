'use strict';

// NOTE: indices must be in descending order

const assert = require('assert');
const { leftShift, and } = require('bitwise-buffer');

const { to32ByteBoolBuffer } = require('./utils');

// This is the MultiIndexedProof.generate algorithm, however, since indices will not be used to
// compute the root at verify-time, a set fo flags need to be generated to indicate, for each
// hash performed at verify-time, whether a previously computed hash will be needed (True), or
// a decommitment will be needed. Since this method only works with hash functions that sort the
// hashed material, there is no need to provide instructions on hashing order. However, such a
// proof would also be possible, with a separate set of flags to instruct the hashing order.
// See MultiIndexedProof.generate for relevant inline comments.
const generateBooleans = ({ tree, indices }) => {
  const known = Array(tree.length).fill(false);
  const relevant = Array(tree.length).fill(false);
  const decommitments = [];
  const flags = [];
  const skips = [];
  const leafCount = tree.length >> 1;

  for (let i = 0; i < indices.length; i++) {
    assert(i === 0 || indices[i - 1] > indices[i], 'Indices must be in descending order');
    known[leafCount + indices[i]] = true;

    // The parent of this node is relevant, as there will be a hash computed at verify-time.
    relevant[(leafCount + indices[i]) >> 1] = true;
  }

  for (let i = leafCount - 1; i > 0; i--) {
    const leftChildIndex = i << 1;
    const left = known[leftChildIndex];
    const right = known[leftChildIndex + 1];
    const sibling = tree[leftChildIndex + left];

    if (left ^ right) decommitments.push(sibling);

    // Since there will be a hash computed at verify-time, push the flag on wether this hash
    // will require a decommitment (False) or a previously computed hash (True). Also, if the
    // sibling of this child does not exist, the sibling must be to the "right" of the
    // "right-most" leaf, so the hash can be skipped in favor of just using the child itself.
    // Further, the parent of this node it itself relevant, in a subsequent iteration.
    if (relevant[i]) {
      flags.push(left === right);
      skips.push(!sibling);
      relevant[i >> 1] = true;
    }

    known[i] = left || right;
  }

  return {
    decommitments: decommitments.filter((d) => d).map(Buffer.from),
    flags,
    skips,
  };
};

// Convert the flags and skips generated by generateBooleans into a 32-byte bit-set
const generateBits = ({ tree, indices }) => {
  const { decommitments, flags, skips } = generateBooleans({ tree, indices });

  assert(flags.length <= 256, 'Proof too large for bit flags.');

  return {
    decommitments,
    flags: to32ByteBoolBuffer(flags),
    skips: to32ByteBoolBuffer(skips),
    hashCount: flags.length,
  };
};

const generate = (parameters) => {
  return parameters.bitFlags ? generateBits(parameters) : generateBooleans(parameters);
};

// This is the MultiIndexedProof.getRoot algorithm, slightly simplified to take into account that
// this is to be used with a hash function that sorts the material it hashes, and thus this uses flags
// to determine hashing content, instead of the indices. Further, this implements skipping hashing for
// nodes without siblings to the "right", in the case of unbalanced trees.
// See MultiIndexedProof.getRoot for relevant inline comments.
const getRootBooleans = ({ leafs, flags, skips, decommitments, hashFunction }) => {
  const hashCount = flags.length;
  const leafCount = leafs.length;
  const hashes = Array(leafCount).fill(null);

  let readIndex = 0;
  let writeIndex = 0;
  let decommitmentIndex = 0;
  let useLeafs = true;

  for (let i = 0; i < hashCount; i++) {
    if (skips[i]) {
      hashes[writeIndex++] = useLeafs ? leafs[readIndex++] : hashes[readIndex++];

      if (useLeafs && readIndex === leafCount) useLeafs = false;

      readIndex %= leafCount;
      writeIndex %= leafCount;
      continue;
    }

    const right = flags[i] ? (useLeafs ? leafs[readIndex++] : hashes[readIndex++]) : decommitments[decommitmentIndex++];
    readIndex %= leafCount;
    const left = useLeafs ? leafs[readIndex++] : hashes[readIndex++];
    hashes[writeIndex++] = hashFunction(left, right);

    if (useLeafs && readIndex === leafCount) useLeafs = false;

    readIndex %= leafCount;
    writeIndex %= leafCount;
  }

  const rootIndex = (writeIndex === 0 ? leafCount : writeIndex) - 1;

  return { root: Buffer.from(useLeafs ? leafs[0] : hashes[rootIndex]) };
};

// This is identical to the above getRootBooleans algorithm, differing only in that the
// the flag and skip bit-set is shifted and checked, rather than boolean arrays.
// See getRootBooleans for relevant inline comments.
const getRootBits = ({ leafs, hashCount, flags, skips, decommitments, hashFunction }) => {
  const leafCount = leafs.length;
  const hashes = Array(leafCount).fill(null);

  let readIndex = 0;
  let writeIndex = 0;
  let decommitmentIndex = 0;
  let useLeafs = true;
  let bitCheck = Buffer.from('0000000000000000000000000000000000000000000000000000000000000001', 'hex');

  for (let i = 0; i < hashCount; i++) {
    if (and(skips, bitCheck).equals(bitCheck)) {
      hashes[writeIndex++] = useLeafs ? leafs[readIndex++] : hashes[readIndex++];

      if (useLeafs && readIndex === leafCount) useLeafs = false;

      readIndex %= leafCount;
      writeIndex %= leafCount;
      bitCheck = leftShift(bitCheck, 1);
      continue;
    }

    const flag = and(flags, bitCheck).equals(bitCheck);
    const right = flag ? (useLeafs ? leafs[readIndex++] : hashes[readIndex++]) : decommitments[decommitmentIndex++];
    readIndex %= leafCount;
    const left = useLeafs ? leafs[readIndex++] : hashes[readIndex++];
    hashes[writeIndex++] = hashFunction(left, right);

    if (useLeafs && readIndex === leafCount) useLeafs = false;

    readIndex %= leafCount;
    writeIndex %= leafCount;
    bitCheck = leftShift(bitCheck, 1);
  }

  const rootIndex = (writeIndex === 0 ? leafCount : writeIndex) - 1;

  return { root: Buffer.from(useLeafs ? leafs[0] : hashes[rootIndex]) };
};

const getRoot = (parameters) => {
  return Buffer.isBuffer(parameters.flags) ? getRootBits(parameters) : getRootBooleans(parameters);
};

// This is identical to the above getRootBooleans algorithm, differing only in that the
// new root (due to the updated leafs), is computed along the way.
// See getRootBooleans for relevant inline comments.
const getNewRootBooleans = ({ leafs, newLeafs, flags, skips, decommitments, hashFunction }) => {
  const hashCount = flags.length;
  const leafCount = leafs.length;
  const hashes = Array(leafCount).fill(null);
  const newHashes = Array(leafCount).fill(null);

  let readIndex = 0;
  let writeIndex = 0;
  let decommitmentIndex = 0;
  let useLeafs = true;

  for (let i = 0; i < hashCount; i++) {
    if (skips[i]) {
      hashes[writeIndex] = useLeafs ? leafs[readIndex] : hashes[readIndex];
      newHashes[writeIndex++] = useLeafs ? newLeafs[readIndex++] : newHashes[readIndex++];

      if (useLeafs && readIndex === leafCount) useLeafs = false;

      readIndex %= leafCount;
      writeIndex %= leafCount;
      continue;
    }

    const right = flags[i] ? (useLeafs ? leafs[readIndex] : hashes[readIndex]) : decommitments[decommitmentIndex];
    const newRight = flags[i]
      ? useLeafs
        ? newLeafs[readIndex++]
        : newHashes[readIndex++]
      : decommitments[decommitmentIndex++];
    readIndex %= leafCount;

    const left = useLeafs ? leafs[readIndex] : hashes[readIndex];
    const newLeft = useLeafs ? newLeafs[readIndex++] : newHashes[readIndex++];
    hashes[writeIndex] = hashFunction(left, right);
    newHashes[writeIndex++] = hashFunction(newLeft, newRight);

    if (useLeafs && readIndex === leafCount) useLeafs = false;

    readIndex %= leafCount;
    writeIndex %= leafCount;
  }

  const rootIndex = (writeIndex === 0 ? leafCount : writeIndex) - 1;

  return {
    root: Buffer.from(useLeafs ? leafs[0] : hashes[rootIndex]),
    newRoot: Buffer.from(useLeafs ? newLeafs[0] : newHashes[rootIndex]),
  };
};

// This is identical to the above getRootBits algorithm, differing only in that the
// new root (due to the updated leafs), is computed along the way.
// See getRootBits for relevant inline comments.
const getNewRootBits = ({ leafs, newLeafs, hashCount, flags, skips, decommitments, hashFunction }) => {
  const leafCount = leafs.length;
  const hashes = Array(leafCount).fill(null);
  const newHashes = Array(leafCount).fill(null);

  let readIndex = 0;
  let writeIndex = 0;
  let decommitmentIndex = 0;
  let useLeafs = true;
  let bitCheck = Buffer.from('0000000000000000000000000000000000000000000000000000000000000001', 'hex');

  for (let i = 0; i < hashCount; i++) {
    if (and(skips, bitCheck).equals(bitCheck)) {
      hashes[writeIndex] = useLeafs ? leafs[readIndex] : hashes[readIndex];
      newHashes[writeIndex++] = useLeafs ? newLeafs[readIndex++] : newHashes[readIndex++];

      if (useLeafs && readIndex === leafCount) useLeafs = false;

      readIndex %= leafCount;
      writeIndex %= leafCount;
      bitCheck = leftShift(bitCheck, 1);
      continue;
    }

    const flag = and(flags, bitCheck).equals(bitCheck);
    const right = flag ? (useLeafs ? leafs[readIndex] : hashes[readIndex]) : decommitments[decommitmentIndex];
    const newRight = flag
      ? useLeafs
        ? newLeafs[readIndex++]
        : newHashes[readIndex++]
      : decommitments[decommitmentIndex++];
    readIndex %= leafCount;

    const left = useLeafs ? leafs[readIndex] : hashes[readIndex];
    const newLeft = useLeafs ? newLeafs[readIndex++] : newHashes[readIndex++];
    hashes[writeIndex] = hashFunction(left, right);
    newHashes[writeIndex++] = hashFunction(newLeft, newRight);

    if (useLeafs && readIndex === leafCount) useLeafs = false;

    readIndex %= leafCount;
    writeIndex %= leafCount;
    bitCheck = leftShift(bitCheck, 1);
  }

  const rootIndex = (writeIndex === 0 ? leafCount : writeIndex) - 1;

  return {
    root: Buffer.from(useLeafs ? leafs[0] : hashes[rootIndex]),
    newRoot: Buffer.from(useLeafs ? newLeafs[0] : newHashes[rootIndex]),
  };
};

const getNewRoot = (parameters) => {
  return Buffer.isBuffer(parameters.flags) ? getNewRootBits(parameters) : getNewRootBooleans(parameters);
};

module.exports = { generate, getRoot, getNewRoot };

// TODO: use separate set of flags for left/right hash order, allowing this to work for non-sorted-hash trees
//       Should be able to infer indices of elements based on proof hash order and flags
// TODO: perhaps we can get rid of hashCount parameter with some combination of unused
//       (flags[i], skips[i]) pair. (i.e. flags[i] is irrelevant if skips[i] is true)
