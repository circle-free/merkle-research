'strict';

const chai = require('chai');
const { expect } = chai;
const { buildTree } = require('../src/common');
const { generateAppendProof, appendLeaf } = require('../src/appendable-tree');

describe('Append-Tree', () => {
  describe('Build Appendable Merkle Tree', () => {
    it('should deterministically build a perfect Appendable Merkle Tree.', () => {
      const items = [
        '0000000000000000000000000000000000000000000000000000000000000001',
        '0000000000000000000000000000000000000000000000000000000000000002',
        '0000000000000000000000000000000000000000000000000000000000000003',
        '0000000000000000000000000000000000000000000000000000000000000004',
        '0000000000000000000000000000000000000000000000000000000000000005',
        '0000000000000000000000000000000000000000000000000000000000000006',
        '0000000000000000000000000000000000000000000000000000000000000007',
        '0000000000000000000000000000000000000000000000000000000000000008',
      ];

      const leafs = items.map((item) => Buffer.from(item, 'hex'));
      const { tree, mixedRoot, root, realLeafCount, leafCount, depth } = buildTree(leafs, { unbalanced: true });

      const expectedNodes = [
        '6bf98ce50fff09718e4801a2be1668fb47d70d065f7eef435c280e384d14d236',
        '6f4feb766c4e9e71bf038b8df02f0966e2bf98fe1eaacfd96e5d036664ca1b3c',
        'a9bb8c3f1f12e9aa903a50c47f314b57610a3ab32f2d463293f58836def38d36',
        '9f71e1879e3b8579db9b2e78c3cea73f3878b754afdbef917992e6764d1741c9',
        'e90b7bceb6e7df5418fb78d8ee546e97c83a08bbccc01a0644d599ccd2a7c2e0',
        '2e174c10e159ea99b867ce3205125c24a42d128804e4070ed6fcc8cc98166aa0',
        'bfd358e93f18da3ed276c3afdbdba00b8f0b6008a03476a6a86bd6320ee6938b',
        '24cd397636bedc6cf9b490d0edd57c769c19b367fb7d5c2344ae1ddc7d21c144',
        '0000000000000000000000000000000000000000000000000000000000000001',
        '0000000000000000000000000000000000000000000000000000000000000002',
        '0000000000000000000000000000000000000000000000000000000000000003',
        '0000000000000000000000000000000000000000000000000000000000000004',
        '0000000000000000000000000000000000000000000000000000000000000005',
        '0000000000000000000000000000000000000000000000000000000000000006',
        '0000000000000000000000000000000000000000000000000000000000000007',
        '0000000000000000000000000000000000000000000000000000000000000008',
      ];

      tree.forEach((node, i) => expect(node.toString('hex')).to.equal(expectedNodes[i]));
      expect(mixedRoot.toString('hex')).to.equal(expectedNodes[0]);
      expect(root.toString('hex')).to.equal(expectedNodes[1]);
      expect(realLeafCount).to.equal(items.length);
      expect(leafCount).to.equal(items.length);
      expect(depth).to.equal(3);
    });

    it('should deterministically build an imperfect Appendable Merkle Tree.', () => {
      const items = [
        '0000000000000000000000000000000000000000000000000000000000000001',
        '0000000000000000000000000000000000000000000000000000000000000002',
        '0000000000000000000000000000000000000000000000000000000000000003',
        '0000000000000000000000000000000000000000000000000000000000000004',
        '0000000000000000000000000000000000000000000000000000000000000005',
        '0000000000000000000000000000000000000000000000000000000000000006',
        '0000000000000000000000000000000000000000000000000000000000000007',
        '0000000000000000000000000000000000000000000000000000000000000008',
        '0000000000000000000000000000000000000000000000000000000000000009',
      ];

      const leafs = items.map((item) => Buffer.from(item, 'hex'));
      const { tree, mixedRoot, root, realLeafCount, leafCount, depth } = buildTree(leafs, { unbalanced: true });

      const expectedNodes = [
        'ee313c2bba3814191d06acf5ce954c9a96ca757b6d071852c7a6ec64479d6e9d',
        '4b74fc901bf589acbcf6e59c166c50ad936798fe554b9534403c1f5aceee28a5',
        '6f4feb766c4e9e71bf038b8df02f0966e2bf98fe1eaacfd96e5d036664ca1b3c',
        '0000000000000000000000000000000000000000000000000000000000000009',
        'a9bb8c3f1f12e9aa903a50c47f314b57610a3ab32f2d463293f58836def38d36',
        '9f71e1879e3b8579db9b2e78c3cea73f3878b754afdbef917992e6764d1741c9',
        '0000000000000000000000000000000000000000000000000000000000000009',
        null,
        'e90b7bceb6e7df5418fb78d8ee546e97c83a08bbccc01a0644d599ccd2a7c2e0',
        '2e174c10e159ea99b867ce3205125c24a42d128804e4070ed6fcc8cc98166aa0',
        'bfd358e93f18da3ed276c3afdbdba00b8f0b6008a03476a6a86bd6320ee6938b',
        '24cd397636bedc6cf9b490d0edd57c769c19b367fb7d5c2344ae1ddc7d21c144',
        '0000000000000000000000000000000000000000000000000000000000000009',
        null,
        null,
        null,
        '0000000000000000000000000000000000000000000000000000000000000001',
        '0000000000000000000000000000000000000000000000000000000000000002',
        '0000000000000000000000000000000000000000000000000000000000000003',
        '0000000000000000000000000000000000000000000000000000000000000004',
        '0000000000000000000000000000000000000000000000000000000000000005',
        '0000000000000000000000000000000000000000000000000000000000000006',
        '0000000000000000000000000000000000000000000000000000000000000007',
        '0000000000000000000000000000000000000000000000000000000000000008',
        '0000000000000000000000000000000000000000000000000000000000000009',
        null,
        null,
        null,
        null,
        null,
        null,
        null,
      ];

      const expectedLeafCount = 1 << Math.ceil(Math.log2(items.length));

      tree.forEach((node, i) => expect(node ? node.toString('hex') : node).to.equal(expectedNodes[i]));
      expect(mixedRoot.toString('hex')).to.equal(expectedNodes[0]);
      expect(root.toString('hex')).to.equal(expectedNodes[1]);
      expect(realLeafCount).to.equal(items.length);
      expect(leafCount).to.equal(expectedLeafCount);
      expect(depth).to.equal(4);
    });
  });

  describe('Generate Append-Proof', () => {
    it('should deterministically generate an Append-Proof for a perfect Appendable Merkle Tree.', () => {
      const items = [
        '0000000000000000000000000000000000000000000000000000000000000001',
        '0000000000000000000000000000000000000000000000000000000000000002',
        '0000000000000000000000000000000000000000000000000000000000000003',
        '0000000000000000000000000000000000000000000000000000000000000004',
        '0000000000000000000000000000000000000000000000000000000000000005',
        '0000000000000000000000000000000000000000000000000000000000000006',
        '0000000000000000000000000000000000000000000000000000000000000007',
        '0000000000000000000000000000000000000000000000000000000000000008',
      ];

      const leafs = items.map((item) => Buffer.from(item, 'hex'));
      const treeObject = buildTree(leafs, { unbalanced: true });
      const { mixedRoot, root, realLeafCount, decommitments } = generateAppendProof(
        treeObject.tree,
        treeObject.realLeafCount
      );

      const expectedMixedRoot = '6bf98ce50fff09718e4801a2be1668fb47d70d065f7eef435c280e384d14d236';
      const expectedRoot = '6f4feb766c4e9e71bf038b8df02f0966e2bf98fe1eaacfd96e5d036664ca1b3c';
      const expectedDecommitments = [];

      expect(mixedRoot.toString('hex')).to.equal(expectedMixedRoot);
      expect(root.toString('hex')).to.equal(expectedRoot);
      expect(realLeafCount).to.equal(items.length);
      decommitments.forEach((value, i) => expect(value.toString('hex')).to.equal(expectedDecommitments[i]));
    });

    it('should deterministically generate an Append-Proof for an imperfect Appendable Merkle Tree.', () => {
      const items = [
        '0000000000000000000000000000000000000000000000000000000000000001',
        '0000000000000000000000000000000000000000000000000000000000000002',
        '0000000000000000000000000000000000000000000000000000000000000003',
        '0000000000000000000000000000000000000000000000000000000000000004',
        '0000000000000000000000000000000000000000000000000000000000000005',
        '0000000000000000000000000000000000000000000000000000000000000006',
        '0000000000000000000000000000000000000000000000000000000000000007',
        '0000000000000000000000000000000000000000000000000000000000000008',
        '0000000000000000000000000000000000000000000000000000000000000009',
      ];

      const leafs = items.map((item) => Buffer.from(item, 'hex'));
      const treeObject = buildTree(leafs, { unbalanced: true });
      const { mixedRoot, root, realLeafCount, decommitments } = generateAppendProof(
        treeObject.tree,
        treeObject.realLeafCount
      );

      const expectedMixedRoot = 'ee313c2bba3814191d06acf5ce954c9a96ca757b6d071852c7a6ec64479d6e9d';
      const expectedRoot = '4b74fc901bf589acbcf6e59c166c50ad936798fe554b9534403c1f5aceee28a5';

      const expectedDecommitments = [
        '6f4feb766c4e9e71bf038b8df02f0966e2bf98fe1eaacfd96e5d036664ca1b3c',
        '0000000000000000000000000000000000000000000000000000000000000009',
      ];

      expect(mixedRoot.toString('hex')).to.equal(expectedMixedRoot);
      expect(root.toString('hex')).to.equal(expectedRoot);
      expect(realLeafCount).to.equal(items.length);
      decommitments.forEach((value, i) => expect(value.toString('hex')).to.equal(expectedDecommitments[i]));
    });
  });

  describe('Verify Append-Proof', () => {
    it('should append a leaf given a valid Append-Proof for a perfect Appendable Merkle Tree.', () => {
      const items = [
        '0000000000000000000000000000000000000000000000000000000000000001',
        '0000000000000000000000000000000000000000000000000000000000000002',
        '0000000000000000000000000000000000000000000000000000000000000003',
        '0000000000000000000000000000000000000000000000000000000000000004',
        '0000000000000000000000000000000000000000000000000000000000000005',
        '0000000000000000000000000000000000000000000000000000000000000006',
        '0000000000000000000000000000000000000000000000000000000000000007',
        '0000000000000000000000000000000000000000000000000000000000000008',
      ];

      const leafs = items.map((item) => Buffer.from(item, 'hex'));
      const { tree, mixedRoot, root, realLeafCount, leafCount } = buildTree(leafs, { unbalanced: true });
      const { decommitments } = generateAppendProof(tree, realLeafCount);

      const newLeaf = Buffer.from('0000000000000000000000000000000000000000000000000000000000000008', 'hex');

      const newTreeData = appendLeaf(newLeaf, mixedRoot, root, realLeafCount);
      const {
        mixedRoot: newMixedRoot,
        root: newRoot,
        realLeafCount: newRealLeafCount,
        leafCount: newLeafCount,
        depth: newDepth,
      } = newTreeData;

      const expectedNewMixedRoot = '03923e99e91058307177f5335906c5b77a149af42057ca43c5f45bb772695034';
      const expectedNewRoot = '1674788035044ec9777d2deeaf4e16d7160d1cbff09614b757f85162b297476e';
      const expectedNewRealLeafCount = 9;
      const expectedNewLeafCount = 16;

      expect(newMixedRoot.toString('hex')).to.equal(expectedNewMixedRoot);
      expect(newRoot.toString('hex')).to.equal(expectedNewRoot);
      expect(newRealLeafCount).to.equal(expectedNewRealLeafCount);
      expect(newLeafCount).to.equal(expectedNewLeafCount);
      expect(newDepth).to.equal(4);
    });

    it('should append a leaf given a valid Append-Proof for an imperfect Appendable Merkle Tree.', () => {
      const items = [
        '0000000000000000000000000000000000000000000000000000000000000001',
        '0000000000000000000000000000000000000000000000000000000000000002',
        '0000000000000000000000000000000000000000000000000000000000000003',
        '0000000000000000000000000000000000000000000000000000000000000004',
        '0000000000000000000000000000000000000000000000000000000000000005',
        '0000000000000000000000000000000000000000000000000000000000000006',
        '0000000000000000000000000000000000000000000000000000000000000007',
        '0000000000000000000000000000000000000000000000000000000000000008',
        '0000000000000000000000000000000000000000000000000000000000000009',
        '000000000000000000000000000000000000000000000000000000000000000a',
        '000000000000000000000000000000000000000000000000000000000000000b',
        '000000000000000000000000000000000000000000000000000000000000000c',
        '000000000000000000000000000000000000000000000000000000000000000d',
        '000000000000000000000000000000000000000000000000000000000000000e',
        '000000000000000000000000000000000000000000000000000000000000000f',
      ];

      const leafs = items.map((item) => Buffer.from(item, 'hex'));
      const { tree, mixedRoot, root, realLeafCount, leafCount } = buildTree(leafs, { unbalanced: true });
      const { decommitments } = generateAppendProof(tree, realLeafCount);

      const newLeaf = Buffer.from('0000000000000000000000000000000000000000000000000000000000000010', 'hex');

      const newTreeData = appendLeaf(newLeaf, mixedRoot, root, realLeafCount, decommitments);
      const {
        mixedRoot: newMixedRoot,
        root: newRoot,
        realLeafCount: newRealLeafCount,
        leafCount: newLeafCount,
        depth: newDepth,
      } = newTreeData;

      const expectedNewMixedRoot = '197ef4c2d6d83db577e9907c320aef9991a926ba060a718c0694d35efb4ae031';
      const expectedNewRoot = '59b52a20e3252cc46cdac45bb75f28e521319d3109ae473cc6001c9b748d48e6';
      const expectedNewRealLeafCount = 16;
      const expectedNewLeafCount = 16;

      expect(newMixedRoot.toString('hex')).to.equal(expectedNewMixedRoot);
      expect(newRoot.toString('hex')).to.equal(expectedNewRoot);
      expect(newRealLeafCount).to.equal(expectedNewRealLeafCount);
      expect(newLeafCount).to.equal(expectedNewLeafCount);
      expect(newDepth).to.equal(4);
    });

    it('should fail to verify an invalid Append-Proof (incorrect mixedRoot).', () => {
      const items = [
        '0000000000000000000000000000000000000000000000000000000000000001',
        '0000000000000000000000000000000000000000000000000000000000000002',
        '0000000000000000000000000000000000000000000000000000000000000003',
        '0000000000000000000000000000000000000000000000000000000000000004',
        '0000000000000000000000000000000000000000000000000000000000000005',
        '0000000000000000000000000000000000000000000000000000000000000006',
        '0000000000000000000000000000000000000000000000000000000000000007',
        '0000000000000000000000000000000000000000000000000000000000000008',
        '0000000000000000000000000000000000000000000000000000000000000009',
        '000000000000000000000000000000000000000000000000000000000000000a',
        '000000000000000000000000000000000000000000000000000000000000000b',
        '000000000000000000000000000000000000000000000000000000000000000c',
        '000000000000000000000000000000000000000000000000000000000000000d',
        '000000000000000000000000000000000000000000000000000000000000000e',
        '000000000000000000000000000000000000000000000000000000000000000f',
      ];

      const leafs = items.map((item) => Buffer.from(item, 'hex'));
      const { tree, mixedRoot, root, realLeafCount, leafCount } = buildTree(leafs, { unbalanced: true });
      const { decommitments } = generateAppendProof(tree, realLeafCount);

      const newLeaf = Buffer.from('0000000000000000000000000000000000000000000000000000000000000010', 'hex');
      const randomHash = Buffer.from('000000000000000000000000000000000000000000000000000000000000000a', 'hex');
      const append = () => appendLeaf(newLeaf, randomHash, root, realLeafCount, decommitments);

      expect(append).to.throw();
    });

    it('should fail to verify an invalid Append-Proof (incorrect root).', () => {
      const items = [
        '0000000000000000000000000000000000000000000000000000000000000001',
        '0000000000000000000000000000000000000000000000000000000000000002',
        '0000000000000000000000000000000000000000000000000000000000000003',
        '0000000000000000000000000000000000000000000000000000000000000004',
        '0000000000000000000000000000000000000000000000000000000000000005',
        '0000000000000000000000000000000000000000000000000000000000000006',
        '0000000000000000000000000000000000000000000000000000000000000007',
        '0000000000000000000000000000000000000000000000000000000000000008',
        '0000000000000000000000000000000000000000000000000000000000000009',
        '000000000000000000000000000000000000000000000000000000000000000a',
        '000000000000000000000000000000000000000000000000000000000000000b',
        '000000000000000000000000000000000000000000000000000000000000000c',
        '000000000000000000000000000000000000000000000000000000000000000d',
        '000000000000000000000000000000000000000000000000000000000000000e',
        '000000000000000000000000000000000000000000000000000000000000000f',
      ];

      const leafs = items.map((item) => Buffer.from(item, 'hex'));
      const { tree, mixedRoot, root, realLeafCount, leafCount } = buildTree(leafs, { unbalanced: true });
      const { decommitments } = generateAppendProof(tree, realLeafCount);

      const newLeaf = Buffer.from('0000000000000000000000000000000000000000000000000000000000000010', 'hex');
      const randomHash = Buffer.from('000000000000000000000000000000000000000000000000000000000000000a', 'hex');
      const append = () => appendLeaf(newLeaf, mixedRoot, randomHash, realLeafCount, decommitments);

      expect(append).to.throw();
    });

    it('should fail to verify an invalid Append-Proof (incorrect real leaf count).', () => {
      const items = [
        '0000000000000000000000000000000000000000000000000000000000000001',
        '0000000000000000000000000000000000000000000000000000000000000002',
        '0000000000000000000000000000000000000000000000000000000000000003',
        '0000000000000000000000000000000000000000000000000000000000000004',
        '0000000000000000000000000000000000000000000000000000000000000005',
        '0000000000000000000000000000000000000000000000000000000000000006',
        '0000000000000000000000000000000000000000000000000000000000000007',
        '0000000000000000000000000000000000000000000000000000000000000008',
        '0000000000000000000000000000000000000000000000000000000000000009',
        '000000000000000000000000000000000000000000000000000000000000000a',
        '000000000000000000000000000000000000000000000000000000000000000b',
        '000000000000000000000000000000000000000000000000000000000000000c',
        '000000000000000000000000000000000000000000000000000000000000000d',
        '000000000000000000000000000000000000000000000000000000000000000e',
        '000000000000000000000000000000000000000000000000000000000000000f',
      ];

      const leafs = items.map((item) => Buffer.from(item, 'hex'));
      const { tree, mixedRoot, root, realLeafCount, leafCount } = buildTree(leafs, { unbalanced: true });
      const { decommitments } = generateAppendProof(tree, realLeafCount);

      const newLeaf = Buffer.from('0000000000000000000000000000000000000000000000000000000000000010', 'hex');
      const append = () => appendLeaf(newLeaf, mixedRoot, root, realLeafCount + 1, decommitments);

      expect(append).to.throw();
    });

    it('should fail to verify an invalid Append-Proof (incorrect decommitments).', () => {
      const items = [
        '0000000000000000000000000000000000000000000000000000000000000001',
        '0000000000000000000000000000000000000000000000000000000000000002',
        '0000000000000000000000000000000000000000000000000000000000000003',
        '0000000000000000000000000000000000000000000000000000000000000004',
        '0000000000000000000000000000000000000000000000000000000000000005',
        '0000000000000000000000000000000000000000000000000000000000000006',
        '0000000000000000000000000000000000000000000000000000000000000007',
        '0000000000000000000000000000000000000000000000000000000000000008',
        '0000000000000000000000000000000000000000000000000000000000000009',
        '000000000000000000000000000000000000000000000000000000000000000a',
        '000000000000000000000000000000000000000000000000000000000000000b',
        '000000000000000000000000000000000000000000000000000000000000000c',
        '000000000000000000000000000000000000000000000000000000000000000d',
        '000000000000000000000000000000000000000000000000000000000000000e',
        '000000000000000000000000000000000000000000000000000000000000000f',
      ];

      const leafs = items.map((item) => Buffer.from(item, 'hex'));
      const { tree, mixedRoot, root, realLeafCount, leafCount } = buildTree(leafs, { unbalanced: true });
      const { decommitments } = generateAppendProof(tree, realLeafCount);

      const newLeaf = Buffer.from('0000000000000000000000000000000000000000000000000000000000000010', 'hex');
      const randomHash = Buffer.from('000000000000000000000000000000000000000000000000000000000000000a', 'hex');
      decommitments[0] = randomHash;
      const append = () => appendLeaf(newLeaf, mixedRoot, root, realLeafCount + 1, decommitments);

      expect(append).to.throw();
    });

    it('should fail to verify an invalid Append-Proof (incorrect decommitment count).', () => {
      const items = [
        '0000000000000000000000000000000000000000000000000000000000000001',
        '0000000000000000000000000000000000000000000000000000000000000002',
        '0000000000000000000000000000000000000000000000000000000000000003',
        '0000000000000000000000000000000000000000000000000000000000000004',
        '0000000000000000000000000000000000000000000000000000000000000005',
        '0000000000000000000000000000000000000000000000000000000000000006',
        '0000000000000000000000000000000000000000000000000000000000000007',
        '0000000000000000000000000000000000000000000000000000000000000008',
        '0000000000000000000000000000000000000000000000000000000000000009',
        '000000000000000000000000000000000000000000000000000000000000000a',
        '000000000000000000000000000000000000000000000000000000000000000b',
        '000000000000000000000000000000000000000000000000000000000000000c',
        '000000000000000000000000000000000000000000000000000000000000000d',
        '000000000000000000000000000000000000000000000000000000000000000e',
        '000000000000000000000000000000000000000000000000000000000000000f',
      ];

      const leafs = items.map((item) => Buffer.from(item, 'hex'));
      const { tree, mixedRoot, root, realLeafCount, leafCount } = buildTree(leafs, { unbalanced: true });
      const { decommitments } = generateAppendProof(tree, realLeafCount);

      const newLeaf = Buffer.from('0000000000000000000000000000000000000000000000000000000000000010', 'hex');
      const append = () => appendLeaf(newLeaf, mixedRoot, root, realLeafCount, decommitments.slice(0, -1));

      expect(append).to.throw();
    });
  });
});
